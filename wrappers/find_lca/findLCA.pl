#! /bin/env perl 

use strict;
use warnings;
use Bio::DB::Taxonomy;
use Bio::DB::Taxonomy::list;
use Bio::Tree::Tree;
use Getopt::Long;
use Pod::Usage;
use Date::Manip;
use BerkeleyDB;
use Math::Combinatorics;
#use Dumpvalue;
use Data::Dumper;
#use Log::Log4perl qw(:easy);
use constant {
	QSEQID => 0,	#0
	SSEQID => 1,	#2
	PIDENT => 2,	#8
	LENGTH => 3,	#
	MISMATCH => 4,	#
	GAPOPEN => 5,	#
	QSTART => 6,	#10
	QEND => 7,	#11
	SSTART => 8,	#14
	SEND => 9,	#15
	EVALUE => 10,	#5
	BITSCORE => 11,	#7
	QLEN => 22,	#13
	SLEN => 23,	#16
};

=head1 NAME 

findLCA.pl

=head1 SYNOPSIS

Parse blast results and performs lowest-common-ancestor queries on NCBI/custom taxonomy
Will either take a tabular blast output file or a fasta file with a blastdb.

=head1 OPTIONS

	-i | --parsed-blast-file	parsed blast file to process
	-o | --outfile=s		output file basename [log will be automatically named]

	-f | --fastafile=s		input fasta file to process
	-b | --blastdb=s		blast database to use if fasta file is specified 
	-t | --taxa-dir			directory containing NCBI taxa files
	
	--taxa-dmp			taxonomy dump generated by loadCustomTaxa
	--taxa-mapdb			taxonomy map berkley db generated by loadCustomTaxa 
	--taxa-map			taxonomy map generated by loadCustomTaxa (only required if reindexing)
	
	--use-gi-taxa-lookup		use gi to taxa lookup [should unless taxonid is in the blastdb]
	
	-l | --logfile=s		output file logname
	-r | --rejectfile=s		list of gi to reject (delimited by newline)
        -s | --synonymfile=s		list of txid to redirect to other txid (2 column delimited by tab)
	-n | --namesfile=s		specify this file to use-min-reads with all the sequences
	
	--query-min-length		minimum query length to include
	--query-min-match		minimum query percent id to include [0.95, 0.90]
	--subject-min-length		minimum subject length to include
	--subject-min-match		minimum subject percent id to include
	--min-match-id=s		minunum percentage match [95, 90]
	--use-min-evalue		consider only hits having lowest evalue
	--use-max-query-coverage	consider only hits having the maximum query cover
	--reindex			recreate the index for the BerkleyDB used for gi2taxalookup
	--maximum-rank=s		lca assignments above this rank will not be reported
	--match-to-rank=s		match to this rank and report a confidence value
	--report-unranked-taxa		default true (these report as "no rank"), (only works for LCA step, does not get rerun for use-min-reads currently)
	--no-unranked-taxa		set report-unranked-taxa to false
	--require-support=s		set required minimum support for taxa
	--no-test-informative		skips the test for informative
	--use-min-bitscore=s		only include if below specified bitscore
	--use-percent-top-bitscore=s	only include reads with less than % difference to top bitscore
	--use-min-reads=s		push identified taxa up until the taxa+ancestors has sufficient reads
	--push-to-descendant		if lca of an ancestor and a descendant, return the descendant

=head1 DESCRIPTION

The extended tabular blast output should be in the format of:

	qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore sallseqid score nident positive gaps ppos qframe sframe qseq sseq qlen slen salltitles

or simply:

	std sallseqid score nident positive gaps ppos qframe sframe qseq sseq qlen slen salltitles

=cut

my $ranks = {
		"domain" => 1,
		"superkingdom" => 1.5,
		"kingdom" => 2,
		"subkingdom" => 3,
		"phylum" => 4,
		"division" => 4,
		"subphylum" => 5,
		"class" => 6,
		"subclass" => 7,
		"order" => 8,
		"suborder" => 9,
		"superfamily" => 9.5,
		"family" => 10,
		"subfamily" => 11,
		"tribe" => 12,
		"subtribe" => 13,
		"genus" => 14,
		"subgenus" => 15,
		"section" => 16,
		"series" => 17,
		"species group" => 17.5,
		"species" => 18,
		"species subgroup" => 18.5,
		"subspecies" => 19,
		"variety" => 20,
		"varietas" => 20,
		"subvariety" => 21,
		"subvarietas" => 21,
		"form" => 22,
		"forma" => 22,
		"subform" => 23,
		"subforma" => 23,
		"no rank" => 24,
	};

my $uninformative = {
			"175245"=>"uncultured fungus",
			"57731"=>"environmental samples",
			"136265"=>"environmental samples",
			"89443"=>"unclassified fungi",
		};

my $options = {};
   $options->{'query-min-length'} = 0;
   $options->{'query-min-match'} = 0;
   $options->{'subject-min-length'} = 0;
   $options->{'subject-min-match'} = 0;
   $options->{'min-match-id'} = 0;
   $options->{'no-test-informative'} = undef;
   $options->{'maximum-rank'} = "genus";
   $options->{'report-unranked-taxa'} = 1;
   $options->{'match-to-rank'} = undef;

GetOptions($options, 
		"parsed-blast-file|i=s",
		"fastafile|f=s",
		"blastdb|b=s",
		"outdir|o=s",
		"outfile=s",
		"logfile=s",
		"rejectfile|r=s",
		"synonymfile|s=s",
		"namesfile|n=s",
		"taxa-dir|t=s",
		"taxa-dmp=s",
		"taxa-map=s",
		"taxa-mapdb=s",
		"query-min-length=s",
		"query-min-match=s",
		"subject-min-length=s",
		"subject-min-match=s",
		"min-match-id=s",
		"use-min-evalue",
		"use-max-query-coverage",
		"use-gi-taxa-lookup",
		"reindex",
		"maximum-rank=s",
		"match-to-rank=s",
		"no-unranked-taxa",
		"require-support=s",
		"no-test-informative",
		"use-min-bitscore",
		"use-percent-top-bitscore=s",
		"use-min-reads=s",
		"push-to-descendant",
		"galaxy",
		"help|h"
	);

pod2usage (-exitval => 2, -verbose => 2) if (defined $options->{'help'});
pod2usage ("Input either blast output file or fasta file with blastdb") if (! defined $options->{'parsed-blast-file'} and ! defined $options->{'fastafile'});  
if (defined $options->{'fastafile'} ) { 
	pod2usage ("Please specify blastdb along with fasta file") if (! defined $options->{'blastdb'});  
	my ($fastafile) = $options->{'fastafile'} =~ /([^\/]*)$/;
	my ($blastdb) = $options->{'blastdb'} =~ /([^\/]*)$/;	
	mkdir $options->{'outdir'} or die "Unable to create output directory\n" if (! -d $options->{'outdir'});
	$options->{'parsed-blast-file'} = $options->{'outdir'}."/".$fastafile."_".$blastdb.".tabularblastout";
}

warn ("use-min-reads filter enabled but namesfiles isn't specified") if (!defined $options->{'namesfile'} && defined $options->{'use-min-reads'});

if (!defined $options->{'outfile'}) {
        $options->{'outfile'} = $options->{'parsed-blast-file'} . ".lca";
	if (defined $options->{'galaxy'}) {
		$options->{'outfile'} = "representative.lca";
	}
}

if (!defined $options->{'logfile'}) {
        $options->{'logfile'} = $options->{'parsed-blast-file'} . ".lca.log";
	if (defined $options->{'galaxy'}) {
		$options->{'logfile'} = "representative.lca.log";
	}
}

if (defined $options->{'require-support'} || $options->{'no-unranked-taxa'})
{
	$options->{'report-unranked-taxa'} = 0;
}

if (defined $options->{'maximum-rank'}){$options->{'maximum-rank'} = lc $options->{'maximum-rank'};}
if (defined $options->{'match-to-rank'}){$options->{'match-to-rank'} = lc $options->{'match-to-rank'};}

die "Unknown maximum-rank: " . $options->{'maximum-rank'} . "\n" if (defined $options->{'maximum-rank'} && !defined $ranks->{$options->{'maximum-rank'}});
die "Unknown match-to-rank: " . $options->{'match-to-rank'} . "\n" if (defined $options->{'match-to-rank'} && !defined $ranks->{$options->{'match-to-rank'}});
if (! defined $options->{'taxa-dir'}) {
	if (! defined $options->{'taxa-dmp'} and ! defined $options->{'taxa-mapdb'}) {
		pod2usage("Please specify the directory containing the indexed taxadump files \"nodes.dmp\" and \"names.dmp\" or use taxa-dmp and taxa-mapdb options") 
	} else {
		pod2usage("Taxonomy Dump DNE") if (! -e $options->{'taxa-dmp'});
		pod2usage("Taxonomy Map DNE") if (! -e $options->{'taxa-mapdb'});
	}
} else {
	pod2usage("Directory containing NCBI taxonomy index does not exist") if (! -e $options->{'taxa-dir'});
	warn "Ignoring taxa-dmp and taxa-mapdb options" if (defined $options->{'taxa-dmp'} or defined $options->{'taxa-mapdb'});
}
pod2usage("Please input a number between 0 and 1 for use-percent-max-bitscore\n") if (defined $options->{'use-percent-max-bitscore'} && (($options->{'use-percent-max-bitscore'} < 0) || ($options->{'use-percent-max-bitscore'} > 1)));
pod2usage("Only use either evalue/query coverage or bitscore to evaluate matches") if ((defined $options->{'use-min-bitscore'} || defined $options->{'use-percent-max-bitscore'}) && (defined $options->{'use-min-evalue'}));

open LOG, ">".$options->{'logfile'};
open OUT, ">".$options->{'outfile'};
open TABLE, ">".$options->{'logfile'}.".tab";
open MISSING, ">missing.txt";
#open WARN, ">warnings.txt";
#open STDERR, '>>', 'warnings.txt' or die;

if (defined $options->{'fastafile'}) {
	if (-f $options->{'fastafile'}) {
	print "blastn", " ",
		"-query ", $options->{'fastafile'}, " ",
		"-db ", $options->{'blastdb'}, " ",
		"-show_gis ", 
		"-outfmt ", "6 std sallseqid score nident positive gaps ppos qframe sframe qseq sseq qlen slen salltitles", " ",
		"-max_target_seqs ", "50", " ",
		"-out ", $options->{'parsed-blast-file'}, "\n";	
	system ("blastn",
		"-query", $options->{'fastafile'},
		"-db", $options->{'blastdb'},
		"-show_gis", 
		"-outfmt", "6 std sallseqid score nident positive gaps ppos qframe sframe qseq sseq qlen slen salltitles",
		"-max_target_seqs", "50",
		"-out", $options->{'parsed-blast-file'});	
	} else { die "fasta file does not exist\n"; }
}

my $start = time;
my $last_log = $start;
my $last = $start;
my $dbh;
if (defined $options->{'taxa-dir'}) {
	if ($options->{'taxa-dir'} !~ /\.dmp$/ && -d $options->{'taxa-dir'}) {
		my $taxadir = $options->{'taxa-dir'};
		printLog("Opening NCBI taxonomy DB: $taxadir");
		$options->{'taxa-map'} = $taxadir."/gi_taxid_nucl.dmp";
		$options->{'taxa-mapdb'} = $taxadir."/gi_taxid_nucl.db";
		$dbh = Bio::DB::Taxonomy->new(-source => 'flatfile',
        	                         -directory => $taxadir,
					);
	} else {
		my $taxadmp = $options->{'taxa-dir'};
		$options->{'taxa-dir'} =~ s/\.dmp$//;
		$options->{'taxa-dmp'} = $taxadmp;
		$options->{'taxa-map'} = $options->{'taxa-dir'}.".map";
		$options->{'taxa-mapdb'} = $options->{'taxa-dir'}.".map.bdb";
		$options->{'custom-taxa'} = $taxadmp;
		printLog("Opening custom taxonomy DB: $taxadmp");
		if (-f $taxadmp and $taxadmp =~ /\.dmp$/) {
			$dbh = eval { do $taxadmp };
			die "Error reading: $@" if $@;
		} else {
			die "Please check that the custom taxonomy files exist\n";
		}
	}
} else {
	printLog("Opening custom taxonomy DB: $options->{'taxa-dmp'}");
	$options->{'custom-taxa'} = $options->{'taxa-dmp'};
	if (-f $options->{'taxa-dmp'}) {
		$dbh = eval { do $options->{'taxa-dmp'} };
		die "Error reading: $@" if $@;
	} else {
		die "Please check that the custom taxonomy files exist\n";
	}
}

my $rejects = {};
if (defined $options->{'rejectfile'})
{
	open REJECT, $options->{'rejectfile'} or die "Unable to open reject file\n";
	while(my $gi = <REJECT>)
	{
		chomp $gi;
		$rejects->{$gi} = 1;
	}
	close REJECT;
}

my $redirects = {};
my @redirects = ();
if (defined $options->{'synonymfile'})
{
	open REDIRECT, $options->{'synonymfile'} or die "Unable to open synonym file\n";;
	while (my $row = <REDIRECT>)
	{
		chomp $row;
		my ($before, $after) = split /\t/, $row;
		push @redirects, $before;
		$redirects->{$before} = $after;
	}
	close REDIRECT;
}

my $namesdata = {};
if (defined $options->{'namesfile'})
{
	open NAMES, $options->{'namesfile'} or die "Unable to open namesfile\n";
        while (<NAMES>)
        {
                chomp;
                my ($representative, $sequences) = split /\t/;
                my @seqlist = split /,/, $sequences;
                $namesdata->{$representative} = scalar @seqlist;
        }
	close NAMES;
}

#get all descendents too
my $redirect_master = {};
@redirects = reordertaxon(@redirects);
foreach my $txid (@redirects)
{
	if (!defined $redirect_master->{$txid})
	{
		$redirect_master->{$txid} = $redirects->$txid;
	}
	my $taxon = $dbh->get_taxon($txid);
	my @nodes = $taxon->get_all_Descendents();
	foreach my $node (@nodes)
	{
		if (!defined $redirect_master->{$node->id})
		{$redirect_master->{$node->id} = $redirects->$txid;}
	}
}


my %taxa;
if (defined $options->{'use-gi-taxa-lookup'}) 
{
	openTaxaLookup(\%taxa, $options->{'taxa-map'}, $options->{'taxa-mapdb'})
}

my $matches = {};
my $lcas = {};

my $id = undef;
my $min_evalue = 10000;
my $max_query_cover = 0;
my $max_bitscore = 0;

open BRT, $options->{"parsed-blast-file"};
my $row_count = 0;
printLog("Starting to process entries");
while (my $row = <BRT>) {

	$row_count++;
	my $current = time;

	if ($row_count % 10 == 0)  {
		printLog("Processed 10 rows in ". ($current - $last). " seconds. Total: $row_count rows in ". ($current - $start). " seconds");
		$last = $current;
	}

	chomp $row;
	my @parts = split "\t", $row;
	my $first_read_bool = 0;
	if ($row =~ /Query Name.*/) {
		#printLog(
		#      "$parts[0], " .
		#      "$parts[2], ".
		#      "$parts[3], ".
		#      "$parts[5], ".
		#      "$parts[6], ".
		#      "$parts[8], ".
		#      "$parts[10], ".
		#      "$parts[11], ".
		#      "$parts[12], ".
		#      "$parts[14], ".
		#      "$parts[15], ".
		#      "$parts[16]\n";
		# skip header
		next;
	}
	# for first or new id; process matches
	if (defined $id && $parts[QSEQID] ne $id) 
	{
		if (scalar keys %$matches > 0) {
			processMatches($options, $id, $matches, $min_evalue, $max_query_cover);
		} else {
			printLog("\tNo suitable matches found.");
			print OUT "Query: " .$id . "\tNo suitable matches found.\n";
		}
		$id = undef;
		$matches = {};
		$min_evalue = 10000; # reset min observed evalue
		$max_query_cover = 0;
		$max_bitscore = 0;
		$first_read_bool = 1;
	}
	if (!defined $id) {
		$id = $parts[QSEQID];
		$first_read_bool = 1;
		printLog("Processing matches for $id");
	}

	printLog(
	      "\t".
	      "$parts[0], ".
	      "$parts[1], ".
	      "$parts[2], ".
	      "$parts[3], ".
	      "$parts[4], ".
	      "$parts[5], ".
	      "$parts[6], ".
	      "$parts[7], ".
	      "$parts[8], ".
	      "$parts[9], ".
	      "$parts[10], ".
	      "$parts[11]"
	);

	my $taxon = undef;
	my $taxon_source = undef;
	if ($parts[SSEQID] =~ /taxon:(\d+)/)
	{
		$taxon = $1;
		$taxon_source = $parts[SSEQID];
		if (defined $options->{'synonymfile'})
		{
			$taxon = redirect($taxon);
			$taxon_source .= " -> $taxon" if $1 ne $taxon;
		}
	}
	elsif ($parts[SSEQID] =~ /^gi\|(\w+)/) 
	{
		$taxon_source = $1;	
		
		die "GI based taxon lookup required; please use --use-gi-taxa-lookup option" if !defined $options->{'use-gi-taxa-lookup'};
		die "Failed to extract gi from result" if (!defined $taxon_source);
		warn "Taxa associated with $taxon_source not found in gi_to_taxa_lookup" if (!defined $taxa{$taxon_source});
        #print the missing GI to missing 
        print MISSING "$taxon_source\n" if (!defined $taxa{$taxon_source});

                if (defined $options->{'rejectfile'})
                {
			if (defined $rejects->{$taxon_source})
                        {
				printLog("\t\tgi: $taxon_source found in reject list, skipping");
                        	next;
			}
                }		

		printLog("\t\tgi: $taxon_source -> txid: " . (defined $taxa{$taxon_source} ? $taxa{$taxon_source} : "undef") . "");
		$taxon = $taxa{$taxon_source};
		if (defined $options->{'synonymfile'} && defined $taxa{$taxon_source}) 
		{
			$taxon = redirect($taxon);
			if ($taxa{$taxon_source} != $taxon)
			{printLog("\t\ttxid: ".$taxa{$taxon_source}. " -> ". $taxon);}
		}
	}
	elsif ($parts[SSEQID] =~ /^\s*([^\|\s]+)(\|)?/) {
		$taxon_source = $1;
		die "Failed to extract gi from result" if (!defined $taxon_source);
		warn "Taxa associated with $taxon_source not found in custom lookup: check option --use-gi-taxa-lookup" if (!defined $taxa{$taxon_source});
		printLog("\t\tcustomid: $taxon_source -> txid: " . (defined $taxa{$taxon_source} ? $taxa{$taxon_source} : "undef") . "");
		$taxon = $taxa{$taxon_source};
	} 
	else
	{
		die "Column 4 doesn't contain a \"taxon:##\" entry, and Column 3 doesn't contain a gi.  Can't process blast results.\n". join("\n", @parts);;
	}

	my $reason = undef;
	if (!screenMatch(\@parts,$options->{'query-min-length'}, $options->{'query-min-match'}, 
				$options->{'subject-min-length'}, $options->{'subject-min-match'},
				$options->{'min-match-id'}, $options->{'use-min-bitscore'},
				$max_bitscore, $options->{'use-percent-top-bitscore'},
				$first_read_bool, \$reason)) 
	{
		print TABLE "$id\t$taxon_source\tfalse\tScreened out: $reason\n";
		next; #theoretically, since matches are ordered by descending bitscore, as soon as one match fails any bitscore test, the rest should too. So we could add a last, but that would skip the table log for those matches, what-to-do?
	}

	
	if (defined $taxon){
		printLog("Looking up node for taxon: $taxon");
		my $node = $dbh->get_taxon($taxon);
		if (defined $node) 
		{
			printLog("Found node ->". " taxid: ". $node->id . " rank: ". $node->rank. " name: ". $node->scientific_name);
			# add taxon_source for taxon match
			push @{$matches->{$taxon}->{'sources'}}, $taxon_source;

			# update global observed min-evalue for this query which is used when processing matches above
			if ($parts[EVALUE] < $min_evalue) {
				printLog("\t\tSetting min_evalue to: " . $parts[EVALUE] . " from Taxon: $taxon_source");
				$min_evalue = $parts[EVALUE];
			}

			# update min-evalue for this taxon
			if (!defined $matches->{$taxon}->{'min-evalue'} || $matches->{$taxon}->{'min-evalue'} > $parts[EVALUE]) 
			{
				# track minimum evalue associated with this txid
				printLog("\t\tKeeping match: $taxon_source as best evalue");
				$matches->{$taxon}->{'min-evalue'} = $parts[EVALUE];
				$matches->{$taxon}->{'min-evalue-source'} = $taxon_source;
			} 
			else 
			{
				printLog("\t\tEquivalent or better match to sequence with this taxon id ($taxon) already found: " . 
						$matches->{$taxon}->{'min-evalue'} . ":" . $parts[EVALUE]);
			}

			#update global observed bitscore for this query which is used when processing matches above
                        if ($first_read_bool || $parts[BITSCORE] > $max_bitscore) {
                                printLog("\t\tSetting max_bitscore to: ". $parts[BITSCORE] . " from Taxon: $taxon_source");
                                $max_bitscore = $parts[BITSCORE];
                        }

			# update global observed max_query_cover for this query which is used when processing matches above
			my $query_cover = abs ($parts[QEND] - $parts[QSTART]) / $parts[QLEN];
			if ($query_cover > $max_query_cover) {
				$max_query_cover = $query_cover;
			}
			
			# update max-query-cover for this taxon
			if (!defined $matches->{$taxon}->{'max-query-cover'} || $matches->{$taxon}->{'max-query-cover'} < $query_cover) 
			{
				# track maximum qcoverage associated with this txid
				printLog("\t\tKeeping match: $taxon_source as best cover: $query_cover");
				$matches->{$taxon}->{'max-query-cover'} = $query_cover;
				$matches->{$taxon}->{'max-query-cover-source'} = $taxon_source;
			} 
			else 
			{
				printLog("\t\tEquivalent or better match to sequence with this taxon id ($taxon) already found: " . 
						$matches->{$taxon}->{'max-query-cover'} . ":" . $query_cover);
			}
			
			# update the max pid (percent identical) for this taxon
			if (!defined $matches->{$taxon}->{'max-pid'} || $matches->{$taxon}->{'max-pid'} > $parts[PIDENT]) {
				$matches->{$taxon}->{'max-pid'} = $parts[PIDENT];
				$matches->{$taxon}->{'max-pid-source'} = $taxon_source;
			}	
		}
		else
		{
			printLog ("Taxon $taxon not found in taxonomy dump\n");
		}
	}
}

# process the final entry
if (scalar keys %$matches > 0) {
	processMatches($options, $id, $matches, $min_evalue, $max_query_cover);
} else {
	printLog("\tNo suitable matches found.");
	print OUT "Query: " .$id . "\tNo suitable matches found.\n";
}
if (defined $options->{'use-min-reads'})
{checkminreadsinit();}

sub printLog {
	my ($message) = @_;
	my $current_time = time;
	my $time = $current_time - $start;
	my $delta = $current_time - $last_log;
	print LOG "$time ($delta): $message\n";
	$last_log = $current_time;
}
sub processMatches {
	my ($options, $id, $matches, $min_evalue, $max_query_cover) = @_;
	printLog("\tMatches");
	foreach my $taxon (keys %$matches) {
		printLog("\t\t$taxon");
	}
	if ($options->{'use-min-evalue'}) {
		printLog("\tRemoving matches with e-value greater than minimum observed e-value ($min_evalue)");
		foreach my $taxon (keys %$matches) {
			if ($matches->{$taxon}->{'min-evalue'} > $min_evalue) {
				my $reason = "evalue: " . $matches->{$taxon}->{'min-evalue'};
				printLog("\t\tdeleting: $taxon $reason");
				foreach my $source (@{$matches->{$taxon}->{'sources'}}) 
				{
					print TABLE "$id\t$source\tfalse\tRemoved matches with e-value greater than minimum observed e-value ($min_evalue): $reason\n";
				}
				delete $matches->{$taxon};
			}
		}
	}

	if ($options->{'use-max-query-coverage'}) {
		printLog("\tRemoving matches with query coverage less than maximum observed coverage ($max_query_cover)");
		foreach my $taxon (keys %$matches) {
			if ($matches->{$taxon}->{'max-query-cover'} < $max_query_cover) {
				my $reason = "query coverage: " . $matches->{$taxon}->{'max-query-cover'};
				printLog("\t\tdeleting: $taxon $reason");
				foreach my $source (@{$matches->{$taxon}->{'sources'}}) 
				{
					print TABLE "$id\t$source\tfalse\tRemoved matches with query coverage less than maximum observed coverage ($max_query_cover): $reason\n";
				}
				delete $matches->{$taxon};
			}
		}
	}
		
	my $hasInformativeTaxon = 0;
	my @uninformative;
	foreach my $taxon (keys %$matches) {
		my $informative = informative($taxon);
		if ($informative == 1) {
			$hasInformativeTaxon = 1;
		} 
		elsif ($informative == -1) {
			if (scalar (keys %$matches) > 1) { # only remove if there are other matches
				printLog("\t\tdeleting no taxonomic info: " . $taxon . "");
                        	foreach my $source (@{$matches->{$taxon}->{'sources'}})
                        	{
                               		my $node = $dbh->get_taxon($taxon);
                                	print TABLE "$id\t$source\tfalse\tRemoved matches to no info taxa: $taxon (" . $node->scientific_name . ")\n";
                        	}
				delete $matches->{$taxon};
			} else {
				printLog("\t\tkeeping taxon only one left: " . $taxon . "");
			}
		}
		else {
			push @uninformative, $taxon;
		}
	}
	
	printLog("\tMatched " . scalar @uninformative . " uninformative taxa");
	if ($hasInformativeTaxon) {
		foreach my $taxon (@uninformative) {
			printLog("\t\tdeleting uninformative: " . $taxon . "");
			foreach my $source (@{$matches->{$taxon}->{'sources'}}) 
			{
				my $node = $dbh->get_taxon($taxon);
				print TABLE "$id\t$source\tfalse\tRemoved matches to uninformative taxa: $taxon (" . $node->scientific_name . ")\n";
			}
			delete $matches->{$taxon};
		}
	} else {
		printLog("\t\tNo \"informative\" matches available, keeping everything");
	}

	foreach my $taxon (keys %$matches) {
		foreach my $source (@{$matches->{$taxon}->{'sources'}}) {
			print TABLE "$id\t$source\ttrue\t\n";
		}
	}

	if (keys %$matches == 0) {
		printLog("\t\tAn error has occurred - there are no remaining matches for this sequence");
		die "No matches left";
	}
	lookupLCA($id, $matches);
}

sub lookupLCA 
{
	my ($id, $matches) = @_;

	my @keys = keys %$matches;

	printLog("\tFind LCA of: $id"); # " . (join ", ", @keys) . "");
	if (defined $options->{'push-to-descendant'}) {printLog("\tUsing push-to-descendant\n");}
	foreach my $taxon (keys %$matches) {
		my $node = $dbh->get_taxon($taxon);
		printLog("\t\t".$taxon . ":" . $node->scientific_name . "");
	}
	my $lca = undef;
	my $support = undef;

	if (defined $options->{'require-support'})
	{
		$lca = hierarchicalLCA(\@keys, $options->{'require-support'}, \$support);
	} 
	elsif (defined $options->{'match-to-rank'}) 
	{
		$lca = assignToRankLCA(\@keys, $options->{'match-to-rank'}, \$support);
	} 
	else 
	{
		$lca = roundRobinLCA(\@keys);
	}
	if (!defined $options->{'use-min-reads'}){printLCAresults($id, $lca, $support, $matches);} 
	else
	{
		printLog ("\t\tCaching results, initial LCA: ".$lca->scientific_name);
		$lcas->{$lca->id}->{$id}->{lca} = $lca;
		$lcas->{$lca->id}->{$id}->{support} = $support;
		$lcas->{$lca->id}->{$id}->{matches} = $matches;
	}
}

sub checkminreadsinit
{
	my @txidlist;
	# we have two options to get all the nodes we need to check, one is just populate all the ancestors beforehand,
	# or we can add the ancestor if a check finds less reads than the minimum, and then reorder the txids, remove the one we checked, and rerun the pushupminread.
	# a third and much harder option, maybe insert the ancestor into the proper place/order in the array
	
	my $tree = new Bio::Tree::Tree();
	for my $txid (keys %$lcas)
	{
		push @txidlist, $txid;
	}
	printLog("\tPushing up identified nodes with less than ".$options->{'use-min-reads'}." reads");
	while (scalar @txidlist > 0)
	{
		@txidlist = checkminreads(\@txidlist); #pass an initial list of all identified nodes in an unknown order
		#print "@txidlist\n";
	}
	#rerun unranked taxa check	
	if (!$options->{'report-unranked-taxa'})
	{
		foreach my $txid (keys %$lcas)
		{
			my $node = $dbh->get_taxon($txid);
			$node = findRankedTaxa($node);
			foreach my $id (keys %{$lcas->{$txid}})
			{
				if ($node->id != $lcas->{$txid}->{$id}->{lca}->id)
				{
					$lcas->{$txid}->{$id}->{lca} = $node;
				}
			}
		}
	}
	#wonder if this loop should be combined with the above loop?
	for my $txid (keys %$lcas)
        {
        	for my $id (keys %{$lcas->{$txid}})
                {
                	printLCAresults($id, $lcas->{$txid}->{$id}->{lca}, $lcas->{$txid}->{$id}->{support}, $lcas->{$txid}->{$id}->{matches});
        	}
	}
}

#TODO Should probably factor out pass and fail later
sub checkminreads
{
	my ($txidlist) = @_;
	my $tree = new Bio::Tree::Tree();
        my @txidlist = @$txidlist;
	foreach my $txid (@txidlist)
        {
                my $node = $dbh->get_taxon($txid);
		my $reads = 0;
		printLog ("\n\t$txid being checked");
		#$reads += scalar keys %{$lcas->{$txid}} if defined $lcas->{$txid};
		$reads += getreads($txid);
                if ($reads < $options->{'use-min-reads'}) #not enough reads at the node
                {
			printLog("\tOnly $reads from self");
			my @immediate_descendents = $dbh->each_Descendent($node);
			foreach my $descendent (@immediate_descendents)
			{
				#$reads += scalar keys %{$lcas->{$descendent->id}} if defined $lcas->{$descendent->id};
				$reads += getreads($descendent->id);
			}
			if ($reads < $options->{'use-min-reads'}) #still not enough reads with immediate descendents
			{
				printLog("\tOnly $reads from self and immediate descendents");
				foreach my $descendent (@immediate_descendents)
				{
					my @all_descendents = $dbh->get_all_Descendents($descendent);
					foreach my $alldescendent (@all_descendents)
					{
						#$reads += scalar keys %{$lcas->{$alldescendent->id}} if defined $lcas->{$alldescendent->id};
						$reads += getreads($alldescendent->id);
					}
				}
				if ($reads < $options->{'use-min-reads'}) #not enough reads, last check
				{
					#fail - push all descendent and self lca to ancestor lca, then delete all of those txids from the checklist, add ancestor txid
                        		my $ancestor = $dbh->ancestor($node);
					printLog("\t$txid:".$node->scientific_name." only has $reads total reads, pushing itself and descendents up to ".$ancestor->id.":".$ancestor->scientific_name);
					printLog("\t\tAffected Nodes");
					my @all_pushnodes = $dbh->get_all_Descendents($node);
					push @all_pushnodes, $node;
					foreach my $pushnode (@all_pushnodes)
                        		{
						if (scalar keys %{$lcas->{$pushnode->id}} < 1){next;} #skip nodes with no sequence assigned
						printLog("\t\t".$pushnode->id.":".$pushnode->scientific_name.",");
                        			printLog("\t\t\tAffected Sequences:");
                        			for my $seq (keys %{$lcas->{$pushnode->id}})
                        			{
                                			printLog("\t\t\t\t$seq,");
                                			$lcas->{$ancestor->id}->{$seq}->{lca} = $ancestor;
                                			delete $lcas->{$pushnode->id}->{$seq}->{lca};
                                			$lcas->{$ancestor->id}->{$seq}->{support} = $lcas->{$pushnode->id}->{$seq}->{support};
                                			delete $lcas->{$pushnode->id}->{$seq}->{support};
                                			$lcas->{$ancestor->id}->{$seq}->{matches} = $lcas->{$pushnode->id}->{$seq}->{matches};
                                			delete $lcas->{$pushnode->id}->{$seq}->{matches};
                                			delete $lcas->{$pushnode->id}->{$seq};
                        			}
						my $iter = 0;
						while ($iter < scalar @txidlist)
                        			{
                        				my $checknode = $dbh->get_taxon($txidlist[$iter]) or warn "failed to get checknode of $txidlist[$iter]";
                                			if ($checknode->id == $pushnode->id) {splice (@txidlist, $iter, 1);} # removes self
                                			else{$iter++;}
                				}
					}
					foreach my $checktxid (@txidlist)
					{
						if ($checktxid == $ancestor->id){return @txidlist;}
					}
					push @txidlist, $ancestor->id;
					return @txidlist; #array modified, should rerun main loop
				}
				else
				{
					#pass - remove self and ancestors txids from checklist
					printLog("\t$txid:".$node->scientific_name." has $reads from self and all descendents");
					my @removelist = $tree->get_lineage_nodes($node);
					push @removelist, $txid;
					foreach my $removetxid (@removelist)
					{
						my $iter = 0;
						while ($iter < scalar @txidlist)
						{
							my $checknode = $dbh->get_taxon($txidlist[$iter]) or warn "failed to get checknode of $txidlist[$iter]";
							if ($checknode->id == $removetxid) {splice (@txidlist, $iter, 1);}
							else{$iter++;}
						}
					}
					return @txidlist;
				}
			}
			else
			{
				#pass - remove self and ancestors txids from checklist
				printLog("\t$txid:".$node->scientific_name." has $reads from self and immediate descendents");
                                my @removelist = $tree->get_lineage_nodes($node);
                                push @removelist, $txid;
                                foreach my $removetxid (@removelist)
                                {
                                	my $iter = 0;
                                        while ($iter < scalar @txidlist)
                                        {
                                        	my $checknode = $dbh->get_taxon($txidlist[$iter]) or warn "failed to get checknode of $txidlist[$iter]";
                                                if ($checknode->id == $removetxid) {splice (@txidlist, $iter, 1);}
                                                else{$iter++;}
                                        }
                        	}
                                return @txidlist;
			}

                }
                else
		{
			#pass - remove self and ancestors txids from checklist
			printLog("\t$txid:".$node->scientific_name." has $reads from self");
                        my @removelist = $tree->get_lineage_nodes($node);
			push @removelist, $txid;
                        foreach my $removetxid (@removelist)
                        {
                                my $iter = 0;
                                while ($iter < scalar @txidlist)
                                {
                                        my $checknode = $dbh->get_taxon($txidlist[$iter]) or warn "failed to get checknode of $txidlist[$iter]";
                                        if ($checknode->id == $removetxid) {splice (@txidlist, $iter, 1);} # removes the node being checked
                                        else{$iter++;}
                                }
                        }
			return @txidlist; #array modified, shnuld rerun main loop
                }
        }
}

sub getreads
{
	my ($txid) = @_;
	my $count = 0;
	if (defined $lcas->{$txid})
	{
		foreach my $seqid (keys %{$lcas->{$txid}})
		{
			if (defined $options->{'namesfile'})
			{
				if (defined $namesdata->{$seqid})
				{
					$count += $namesdata->{$seqid};
				}
				else
				{
					warn "$seqid present in .parsed file but not in .names file\n";
				}
			}
			else
			{
				$count += scalar keys %{$lcas->{$txid}};
			}
		}
	}
	return $count;	
}

sub printLCAresults
{
	my ($id, $lca, $support, $matches) = @_;
	my @keys = keys %$matches;

	my $old_lca = $lca;
	my $uniq_taxa = {};
	foreach my $taxon (@keys) {
		$uniq_taxa->{$taxon} = scalar (keys $matches->{$taxon}->{'sources'});
	}

	if (defined $options->{'use-min-reads'}) {printLog("\tLCA of $id");}

	if (defined $options->{'synonymfile'})
        {
		$lca = $dbh->get_taxon(redirect($lca->id));
        }

	print OUT "Query: $id\tLCA: " . $lca->id . 
			"\tName:" . $lca->scientific_name . 
			"\tRank: " . $lca->rank;
	
	if ($old_lca->id ne $lca->id)
	{
		printLog("\tLCA: " . $old_lca->id ." -> ". $lca->id .
                        "\tName:" . $old_lca->scientific_name . " -> ". $lca->scientifi_name .
                        "\tRank: " . $old_lca->rank . " -> " . $lca->rank);
	}
	else	
	{
		printLog("\tLCA: " . $lca->id . 
			"\tName:" . $lca->scientific_name . 
			"\tRank: " . $lca->rank);
	}

	my $info = {
		'Evalue' => 'min-evalue',
		'Pid' => 'max-pid',
		'Qcover' => 'max-query-cover',
		'SourceGI' => 'sources',
	};
	my $printed = {};
	if (!defined $options->{'require-support'} && !defined $options->{'match-to-rank'})
	{ 
		print OUT 
			"\tMatches: " . (scalar @keys) . 
			"\tNames: ";

		printLog(
			"\tMatches: " . (scalar @keys) . 
			"\tNames: ");

		foreach my $taxon(keys %$uniq_taxa) 
		{
			print OUT $dbh->get_taxon($taxon)->scientific_name.":".$uniq_taxa->{$taxon}.",";
			printLog($dbh->get_taxon($taxon)->scientific_name.":".$uniq_taxa->{$taxon}.",");
		}
		
		foreach my $stat (sort keys %$info) {
			print OUT "\t$stat: ";		
			printLog ("\t$stat: ");
			my $fullname = $info->{$stat};
	                
			foreach my $taxon (keys %{$uniq_taxa}) {
				if ($fullname eq 'sources') {
					foreach my $value (@{$matches->{$taxon}->{$fullname}}) {
						if (! defined $printed->{$stat}->{$value}) {
							$printed->{$stat}->{$value} = 1;
							print OUT $value . ",";
							printLog ("$value,");
						}
					}
				} else {
					my $value = $matches->{$taxon}->{$fullname};
					if (! defined $printed->{$stat}->{$value}) {
						$printed->{$stat}->{$value} = 1;
						print OUT $value . ",";
						printLog ("$value,");
					}
				}
			}
		}	
	}

	if (defined $options->{'require-support'} || defined $options->{'match-to-rank'})
	{
		print OUT "\tSupport: " . $support->{count}. "/". (scalar @keys);
		printLog("\tSupport: " . $support->{count}. "/". (scalar @keys));
		
		foreach my $stat (sort keys %$info) {
			print OUT "\t$stat: ";		
			printLog ("\t$stat: ");
			my $fullname = $info->{$stat};
	                
			foreach my $taxon (keys %{$support->{children}}) {
				if ($fullname eq 'sources') {
					foreach my $value (@{$matches->{$taxon}->{$fullname}}) {
						if (! defined $printed->{$stat}->{$value}) {
							$printed->{$stat}->{$value} = 1;
							print OUT $value . ",";
							printLog ("$value,");
						}
					}
				} else {
					my $value = $matches->{$taxon}->{$fullname};
					if (! defined $printed->{$stat}->{$value}) {
						$printed->{$stat}->{$value} = 1;
						print OUT $value . ",";
						printLog ("$value,");
					}
				}
			}
		} 
		
		print OUT "\tNames: ";
		printLog("\tNames: ");
		foreach my $taxon (keys %{$support->{children}})
		{
			print OUT $dbh->get_taxon($taxon)->scientific_name.":".$uniq_taxa->{$taxon}.",";
			printLog($dbh->get_taxon($taxon)->scientific_name.":".$uniq_taxa->{$taxon}.",");
		}
		
		print OUT "\tRemoveGI: ";
		printLog("\tRemoveGI: ");
		foreach my $taxon (keys %{$uniq_taxa})
		{
			if (!defined $support->{children}->{$taxon})
			{
				foreach my $value (@{$matches->{$taxon}->{'sources'}}) {
					if (! defined $printed->{'RemoveGI'}->{$value}) {
						$printed->{'RemoveGI'}->{$value} = 1;
						print OUT $value . ",";
						printLog ("$value,");
					} 
				}
			}
		}
		print OUT "\tRemoved: ";
		printLog("\tRemoved: ");
		foreach my $taxon (keys %{$uniq_taxa})
		{
			if (!defined $support->{children}->{$taxon})
			{
				print OUT $dbh->get_taxon($taxon)->scientific_name.":".$uniq_taxa->{$taxon}.",";
				printLog ($dbh->get_taxon($taxon)->scientific_name.":".$uniq_taxa->{$taxon}.",");
			}
		}
	}

	print OUT "\n";
	printLog("");
}

sub assignToRankLCA
{
	my ($keys, $supportval, $support) = @_;
	my @keys = @$keys;
	my $count = scalar @keys;

	my $lca = roundRobinLCA($keys);

	printLog ("Round robin LCA: ". $lca->rank. "\t". $lca->scientific_name. "\t". "require: $supportval");

	my $tree = new Bio::Tree::Tree();
	my $counts = {};
	my $support_count = $count;
	my $support_max = $count;
	# if the rank is below the target rank, work up the ancestor chain
	# if the rank is above the target rank, find the target level node with the most children
	if ($ranks->{$lca->rank} > $ranks->{lc $supportval})
	{
		printLog ("\tMoving up to $supportval level assignment");
		my @lineage = $tree->get_lineage_nodes($lca);
		foreach my $t (reverse @lineage)
		{
			if ($ranks->{$t->rank} <= $ranks->{lc $supportval})
			{
				$lca = $t;
				last;
			}
		}
		foreach my $key (@keys)
		{
			$counts->{$lca->rank}->{names}->{$lca->id}->{children}->{$key}++;
			$counts->{$lca->rank}->{names}->{$lca->id}->{count}++;
		}
	}
	elsif ($ranks->{$lca->rank} < $ranks->{lc $supportval})
	{
		printLog ("\tPushing down to $supportval level assignment");
		foreach my $key (@keys) 
		{
			my $taxon = $dbh->get_taxon($key);
			printLog ("\tChecking $key, ". $taxon->scientific_name. " rank: " . $taxon->rank);
			my @ancestors = $tree->get_lineage_nodes($taxon);
			printLog ("\t\tHas ". scalar @ancestors. " ancestors");
			foreach my $ancestor (@ancestors)
			{
				printLog ("\t\t\t". $ancestor->rank. " ". $ancestor->id. " ". $ancestor->scientific_name);
				$counts->{$ancestor->rank}->{names}->{$ancestor->id}->{count}++;
				$counts->{$ancestor->rank}->{names}->{$ancestor->id}->{taxon} = $ancestor;
				$counts->{$ancestor->rank}->{names}->{$ancestor->id}->{children}->{$key}++;
				$counts->{$ancestor->rank}->{total}++;
			}
		}
		printLog ("\t$supportval level possibilities");
		foreach my $id (keys %{$counts->{$supportval}->{names}})
		{
			printLog ("\t\t". $counts->{$supportval}->{names}->{$id}->{taxon}->scientific_name. 
				  "\t". $counts->{$supportval}->{names}->{$id}->{count}. 
				  "\t". $counts->{$supportval}->{total});
		}
		if (scalar keys %{$counts->{$supportval}->{names}} > 1)
		{
			my @targets = sort {$counts->{$supportval}->{names}->{$b}->{count} <=> 
					$counts->{$supportval}->{names}->{$a}->{count}} keys %{$counts->{$supportval}->{names}};
			printLog ("\t\tMax: " . $counts->{$supportval}->{names}->{$targets[0]}->{count} . "/" . $counts->{$supportval}->{total});	
			$lca = $counts->{$supportval}->{names}->{$targets[0]}->{taxon};
			$support_count = $counts->{$supportval}->{names}->{$targets[0]}->{count};
			$support_max = $counts->{$supportval}->{total};
		} else {
			printLog ("\t\tUnassignable to $supportval level");
		}
	}
	else # $lca->rank == $supportval
	{
		foreach my $key (@keys)
        	{
        	        $counts->{$lca->rank}->{names}->{$lca->id}->{children}->{$key}++;
        	        $counts->{$lca->rank}->{names}->{$lca->id}->{count}++;
        	}
	}
	$$support = $counts->{$lca->rank}->{names}->{$lca->id};
	printLog ("\tAssigned to Rank: ". $lca->rank. "\t". $lca->scientific_name. "\tSupport: $support_count / $support_max");
	return $lca;
}

sub hierarchicalLCA
{
	my ($keys, $pid, $support) = @_;
	my @keys = @$keys;
	my $originals = {};
	foreach my $key (@keys)
	{
		$originals->{$key} = 1;
	}

	my $count = scalar @keys;

	if ($count == 1)
	{
		$$support = {children=>{$keys[0]=>1}, count=>1};
		my $taxon = $dbh->get_taxon($keys[0]);
		return $taxon;
	}

	my $tree = new Bio::Tree::Tree();
	my $ptree = {};
	while (@keys > 1)
	{
		printLog ("Keyes Loop: @keys");
		my $parents = {};
		my @combos = combine(2, @keys);
		foreach my $combo (@combos)
		{
			printLog ("LCAers: $combo->[0] $combo->[1]");
			my $lca = roundRobinLCA($combo);
			printLog ("LCA: ".$lca->id);
			$parents->{$lca->id}++;
			$ptree->{$lca->id}->{name} = $lca->scientific_name;
			$ptree->{$lca->id}->{rank} = $lca->rank;
			if ($lca->id ne $combo->[0] && defined $originals->{$combo->[0]})
			{
				printLog("Added Support: ".$combo->[0]);
				$ptree->{$lca->id}->{children}->{$combo->[0]}++;
				$ptree->{$lca->id}->{count} = scalar keys %{$ptree->{$lca->id}->{children}};
			}
			if ($lca->id ne $combo->[1] && defined $originals->{$combo->[1]})
			{
				printLog("Added Support: ".$combo->[1]);
				$ptree->{$lca->id}->{children}->{$combo->[1]}++;
				$ptree->{$lca->id}->{count} = scalar keys %{$ptree->{$lca->id}->{children}};
			}
		}
		@keys = keys %$parents;
	}


	my $current = undef;
	foreach my $key (sort {$ptree->{$b}->{count} <=> $ptree->{$a}->{count}} keys %$ptree)
	{
		my $taxon= $dbh->get_taxon($key);
		if (!defined $current) 
		{
			$current = $taxon;
			$$support = $ptree->{$key};
		} 
		elsif (!defined $ranks->{$current->rank} || !defined $ranks->{$taxon->rank})
		{
			printLog("\t\t\tUnsupported rank for either ". $current->rank. " or ". $taxon->rank. "");
			warn "No rank for either ". $current->rank. " or ". $taxon->rank. "\n";
		}
		elsif (($ptree->{$key}->{count} / $count) >= $pid &&
			$ranks->{$current->rank} < $ranks->{$taxon->rank})
		{
			$current = $taxon;
			$$support = $ptree->{$key};
		}
		printLog("\t\tCommon Ancestor: $key\t".
			$taxon->scientific_name.
			"\t".
			"Rank: ".
			$taxon->rank.
			"\t".
			"Support: ".
			$ptree->{$key}->{count});
	}
	return $current;
}

sub roundRobinLCA
{
	#print "\n\n$id\n";
	my ($keys) = @_;
	my @keys = @$keys;
	@keys = reordertaxon(@keys) if defined $options->{'push-to-descendant'};
	my $tree = new Bio::Tree::Tree();
	my $lca;
	my $nodeA = $dbh->get_taxon($keys[0]);
	#print STDOUT "First node: ".$nodeA->scientific_name."\n";
	foreach my $taxon (@keys) {
		my $nodeB = $dbh->get_taxon($taxon);
		#print STDOUT "Next node: ".$nodeB->scientific_name."\n";
		$lca = $tree->get_lca($nodeA, $nodeB);
		#print STDOUT "LCA: ".$lca->scientific_name."\n";
		if (defined $options->{'push-to-descendant'} && $lca->id == $nodeB->id)
		{
			$lca = $nodeA;
			#print STDOUT "Enacting push to descendant: new LCA: ".$lca->scientific_name."\n";
		}
		$nodeA = $lca;
		#print STDOUT "First node: ".$nodeA->scientific_name."\n";
	}
	if (!$options->{'report-unranked-taxa'})
	{
		$lca = findRankedTaxa($lca);
	}

	return $lca;
}

sub reordertaxon
{
        my @txids = @_;
        printLog (scalar @txids);
        printLog ("B: @txids");
        my $order = {};
        foreach my $txid (@txids)
        {
                my $taxon = $dbh->get_taxon($txid);
                push @{$order->{$ranks->{$taxon->rank}}}, $txid;
                printLog ("adding $txid to $ranks->{$taxon->rank}");
        }
        @txids = ();
        foreach my $key (sort { $b <=> $a } keys %$order)
        {
                push @txids, @{$order->{$key}};
        }
	printLog ("A: @txids");
        return @txids;
}

sub findRankedTaxa
{
	my ($lca) = @_;

	if (!defined $lca->rank || $lca->rank eq "no rank")
	{
		my $tree = new Bio::Tree::Tree();
		my @lineage = $tree->get_lineage_nodes($lca);

		foreach my $taxa (reverse @lineage)
		{
			if (defined $taxa->rank && $taxa->rank ne "no rank")
			{
				$lca = $taxa;
				last;
			}
		}
	}

	return $lca;
}

sub informative {
	my ($taxon) = @_;
	if (defined $options->{"no-test-informative"}) {return 1;}
	my $tree = new Bio::Tree::Tree();
	my $taxon_node = $dbh->get_taxon($taxon);
	printLog("\tTest whether txid:" . $taxon_node->id . " is informative");
	my @lineage = $tree->get_lineage_nodes($taxon_node);
	my $hasinfo = 0;
	my $badancestor = 0;
	foreach my $parent_node (@lineage) {
		if ($parent_node->rank ne "no rank") { $hasinfo = 1; }
		if ($parent_node->scientific_name =~ /(uncultured|environmental)/) { $badancestor = 1; }
	}
	if (!$hasinfo) {
		printLog("\t\tNo taxonmic information reference sequences not reliable");
		return -1;
	}
	if ($badancestor) {
		printLog("\t\tSpecies belonging to unclassified/environmental categories are not informative");
		return 0;
	}
	if ($taxon_node->scientific_name =~ /uncultured/ ||
		$taxon_node->scientific_name =~ /environmental/) {
		printLog("\t\tUncultured & Environmental reference sequences not reliable");
		return 0;
	}
	if (! defined $options->{'custom-taxa'}) {
		foreach my $ut (keys %$uninformative) {
			my $ut_node = $dbh->get_taxon($ut);
			my $lca = $tree->get_lca($ut_node, $taxon_node);
			if ($lca->id == $ut_node->id) {
				printLog("\t\tChild of uninformative node: txid:" . $ut . "");
				return 0;
			}
		}
	}
	if ($options->{'maximum-rank'}) {
		my $iter = $taxon_node;
		$iter = findRankedTaxa($iter);
		
		die "Unknown rank: " . $iter->rank . "\n" if !defined $ranks->{$iter->rank};
		if ($ranks->{$iter->rank} < $ranks->{$options->{'maximum-rank'}}) {
			printLog("\t\tRank: " . $iter->rank . " above maximum: " . $options->{'maximum-rank'} . "");
			return 0;
		}
	}
	return 1;
}

sub screenMatch {
	my ($parts, $qmin_length, $qmin_match, $smin_length, $smin_match, $min_id, $min_bitscore, $max_bitscore, $percent_top_bitscore, $first_read_bool, $reason) = @_;
	my $pident = $$parts[PIDENT];
	my $qmlen = abs ($$parts[QEND] - $$parts[QSTART] );
	my $qmper = $qmlen/$$parts[QLEN];
	my $smlen = abs ($$parts[SEND] - $$parts[SSTART] );
	my $smper = $smlen/$$parts[SLEN];
	my $bitscore = $$parts[BITSCORE];

	if (defined $min_id && $pident < $min_id) {
		$$reason = "match pid too low: " . $pident . "<" . $min_id;
	} 
	elsif (defined $qmin_length && $qmlen < $qmin_length) 
	{
		$$reason = "seq too short: " . $qmlen. "<" . $qmin_length;
	}
	elsif (defined $qmin_match && $qmper < $qmin_match) 
	{
		$$reason = "query match too short: " . $qmper . "<" . $qmin_match;
	}
	elsif (defined $smin_length && $smlen < $smin_length) 
	{
		$$reason = "seq too short: " . $smlen . "<" . $smin_length;
	}
	elsif (defined $smin_match && $smper < $smin_match) 
	{
		$$reason = "subject match too short: " . $smper . "<" . $smin_match;
	}
	elsif (defined $min_bitscore && $bitscore < $min_bitscore)
	{
		$$reason = "match bitscore too low: " . $bitscore . "<" . $min_bitscore;
	}
	elsif (defined $percent_top_bitscore && !$first_read_bool && $bitscore < ((1-$percent_top_bitscore) * $max_bitscore))
	{
		$$reason = "match bitscore too far below max bitscore " . $bitscore . "<" . ((1-$percent_top_bitscore)*$max_bitscore);
	}
	#printLog ("TEST: ". ((1-$percent_top_bitscore)*$max_bitscore));
	#printLog ("max: ". $max_bitscore);
	#printLog ("percent: ". $percent_top_bitscore);
	if (defined $$reason) {
		printLog("\t\tSkipping " . $$reason . "");
		return 0;
	} else {
		return 1;
	}
}

sub openTaxaLookup 
{
	my ($taxa, $mapping, $database) = @_;
	printLog("Opening $database database");
	if (! -f $database) 
	{
		die "Please taxa-map or taxa-mapdb options" if (! -f $mapping);
		print STDERR "Indexing gi_taxid_nucl entries (this will take a while)\n";
		tie %$taxa, 'BerkeleyDB::Btree', 
				-Filename => $database, 
				-Flags => DB_CREATE;

		my $num = `wc -l $database | cut -f 1 -d ' '`;
		chomp $num;
		my $i = 0;
		open GI2T, $mapping or die "Unable to open mapping: $mapping\n";
		my $start = time;
		while (my $line = <GI2T>) {
			$i++;
			chomp $line;
			my ($gi, $tx) = split "\t", $line;
			$taxa->{$gi} = $tx;
			if ($i % 1000000 == 0) {
				my $current = time;
				print STDERR "Added $i of $num entries in " . ($current - $start) . "s\n";
				$start = $current;
			}
		}
		close GI2T;
	} 
	else 
	{
		tie %$taxa, 'BerkeleyDB::Btree', 
				-Filename => $database,
				-Flags => DB_RDONLY;
	}
}

sub redirect
{
	my ($txid) = @_;

	if (defined $redirect_master->{$txid})
	{
		printLog("\t\tTaxonid: $txid found in synonym list, redirecting $txid -> $redirect_master->{$txid}\n");
		return $redirect_master->{$txid};
	}
	return $txid;
}
