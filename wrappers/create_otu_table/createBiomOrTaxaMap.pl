#!/bin/env perl

use warnings;
use strict;
use Data::Dumper;
use Getopt::Long;
use Pod::Usage;
use Bio::DB::Taxonomy;
use Bio::DB::Taxonomy::list;
use Bio::Tree::Tree;

=head1 NAME

createBiomOrTaxaMap.pl

=head1 SYNOPSIS

This script generates a classic OTU table or a taxonomy mapping file using our custom .lca file format
along with a cluster mapping file generated by createClusterMap.pl. It also contains some options to
filter down or print certain columns of these two files. 

=head1 OPTIONS

        Required: 
                -l | --lcafile          lca identification file to match the OTUs to identifications
                -m | --mapping		sequence mapping file of the clustered sequences to detemine the OTUs
                -t | --taxa-dir         path to the ncbi taxonomy database/custom database
                -o | --output		output OTU file name [DEFAULT: classic otu table]
		
		--names			by default will assume tab spererated cluster mapping use this for names 
		--taxa-map		produce the taxonomy mapping file using seqids
        
        Filters: 
                -e | --evalue           only print OTUs with lower evalue than specified
                -p | --pid              only print OTUs with higher pid than specified
                -q | --query-cover      only print OTUs with higher query coverage then specified

        Optional:
                --full-taxa		gives the full lineage with ranks "[rank] name; ..."
		--no-sample-counts	does not print the sample counts for the otu table
		--total-counts		used to print only the total sequence counts only
                --representative        appends representative sequence for each cluster
                -h | --help             display this help message

=head1 DESCRIPTION

The script generates two different types of output files:

1) classic otu table

	By default will produce the classic otu table. Any of the optional params can be used with it.
	It also provides the ability to filter based on the evalue, pid or query-cover of the lca identifications.

2) taxonomy mapping file 

	To produce the taxa-map file no cluster mapping file only the .lca file. Only the full-taxa flag can be used, 
	if others specified they will be ignored. 

=cut 


my $options = {};
GetOptions ($options,
		"names",
		"mapping|m=s",
		"output|o=s",
		"lcafile|l=s",
		"taxa-dir|t=s",
		"taxa-map",
		"no-sample-counts",
		"total-counts",
		"full-taxa",
		"evalue|e=s",
		"pid|p=s",
		"query-cover|q=s",
		"help|h",
		"representative",
		"referencefile|r=s",
	   );
if (defined $options->{'help'}){ pod2usage(-exitval => 2, -verbose => 2); }
if (! defined $options->{'mapping'}) {
	if (! defined $options->{'taxa-map'}) {
		pod2usage("Please specify mapping file or use taxa-map flag");
	}
}
if (! defined $options->{'output'}) {
	if (defined $options->{'taxa-map'}) {
		$options->{'output'} = "otu_table.map"; 
	} else {
		$options->{'output'} = "otu_table.tab";
	}
}
pod2usage("Undefined lca file\n") if (! defined $options->{'lcafile'});
pod2usage("Undefined taxonomy dir\n") if (! defined $options->{'taxa-dir'});

my $REF = {};		# storing the reference information
my $OTU = {};		# storing the OTU information
my @SAMPLE;
my $LCALOOKUP = {};
my @ranks = qw(superkingdom kingdom phylum subphylum class subclass order family subfamily tribe genus species);
my $abv_ranks = {
	'superkingdom' => 'sk',
        'kingdom' => 'k',
        'phylum' => 'p',
        'subphylum' => 'sp',
        'class' => 'c',
        'subclass' => 'sc',
        'order' => 'o',
        'family' => 'f',
	'subfamily' => 'sf',
	'tribe' => 't',
        'genus' => 'g',
        'species' => 's',
}; 

my $dbh; # open taxonomy database
print STDOUT "Opening taxonomy database: $options->{'taxa-dir'}\n";
if ($options->{'taxa-dir'} !~ /\.dmp$/ && -d $options->{'taxa-dir'}) {
	$dbh = Bio::DB::Taxonomy->new (	
				-source => 'flatfile',
			  	-directory => "$options->{'taxa-dir'}"
				);	
} else {
        if (-f $options->{'taxa-dir'}) {
                $dbh = eval { do $options->{'taxa-dir'} };
                die "Error reading: $@" if $@;
        } else {
                die "Please check that the custom taxonomy files exist\n";
        }
}
print STDOUT "Done opening database.\n";

# read in cluster mapping file and store all the counts in $OTU 
# returns a hash of a list of unique sample
if (defined $options->{'mapping'}) { 
	my $samples = parseClusterMap ($options->{'mapping'}, $options->{'names'}); # read in the names file

	# sort samples
	if (scalar keys %{$samples} > 1) {
		@SAMPLE = sort naturalsort (keys $samples);
	} else {
		@SAMPLE = sort (keys $samples);
	}
}
my @REP = cacheLCAtaxid ($options->{'lcafile'}); # find the names and id of each cluster rep

# write OTU table to disk
if (defined $options->{'taxa-map'}) {
	writeTaxaMap ($options->{'output'});
} else {
	writeOTUtable ($options->{'output'}); 
}

sub parseClusterMap {
	my ($clusterfile, $names) = @_;
	print STDOUT "Reading in names file...\n";
	open CLUSTR, "<$clusterfile" or die "Unable to open $clusterfile\n";
	my $samples = {};
	my $cluster = 0;	# cluster/otu number
        while (my $line = <CLUSTR>) {
                chomp $line;
		my @sequences; 	# stores all member sequences
		if (defined $names) {
                	my ($repID, $sequences) = split "\t", $line;
			@sequences = split (",", $sequences);
			$OTU->{$cluster}->{'rep'} = $repID;
		} else {
			@sequences = split ("\t", $line);
			$cluster = shift @sequences;
			$OTU->{$cluster}->{'rep'} = $sequences[0];
		}
		foreach my $platemid (@sequences) {
			if ($platemid =~ /_/) {
				$platemid =~ s/_.*//;
			} else {
				$platemid = "SAMPLE0";
			}
			if (! defined $samples->{$platemid}) { 
				$samples->{$platemid} = 1; 
			}
			if (! defined $OTU->{$cluster}->{'total'}) {
				$OTU->{$cluster}->{'total'} = 1;
			} else {
				$OTU->{$cluster}->{'total'} += 1;
			}
			if (! defined $OTU->{$cluster}->{$platemid}) { 
				$OTU->{$cluster}->{$platemid} = 1;
			} else { 
				$OTU->{$cluster}->{$platemid} += 1; 
			}
		}
		$cluster++;
        }
	print STDOUT "Done reading names file.\n";
	return $samples;
}

sub writeTaxaMap {
	my ($taxamap) = @_;
	open OUT, ">$taxamap" or die "unable to open output file $taxamap";
	print STDOUT "Writting taxa map to file ...\n";
	print OUT "RepSeqID\tTaxonomy\n";
	for my $repseq (@REP) {
		print OUT $repseq."\t";
		if (defined $LCALOOKUP->{$repseq}->{'txid'})
		{ 
			my $lineage = getLineage($LCALOOKUP->{$repseq}->{'txid'});
			$lineage =~ s/; $//;
			print OUT $lineage."\n";
		}
		else { print OUT "Unassignable\n";}
	}
	close OUT; 
	print STDOUT "DONE\n";
}

sub writeOTUtable {
	my ($otutable) = @_;
	open OUT, ">$otutable" or die "unable to open output file $otutable";
	my $scrap = 0;
	if ( defined $options->{'evalue'} || defined $options->{'query-cover'} || defined $options->{'pid'} ) 
	{
		open OUTSCRAP, ">$otutable.scrap" or die "unable to make scrap OTU table";
		$scrap = 1;
	}
	my @FH = qw/OUT/;
	if ($scrap == 1) { push (@FH, "OUTSCRAP"); }
	foreach (@FH) {
		select $_;	
		print "#OTU ID\t"; 
		if (! defined $options->{'no-sample-counts'}) {
			if (defined $options->{'total-counts'}) {
				print "TOTAL\t";
			} else {
				print "$_\t" foreach (@SAMPLE);
			}
		}
		print "representative\t" if (defined $options->{'representative'});
		print "taxonomy\n"; 
	}

	for my $cluster (sort {$a <=> $b}(keys %{$OTU})) {
		my $seqid = $OTU->{$cluster}->{'rep'};
		select OUT; # reset file handle to OUT
		# change file handle to scrap is does not pass criteria
		if (defined $LCALOOKUP->{$seqid}->{'txid'}) {
			if ( defined $options->{'evalue'} ) { 
				if ($LCALOOKUP->{$seqid}->{'evalue'} > $options->{'evalue'}) {
					select OUTSCRAP;
					#print "evalue: ".$LCALOOKUP->{$seqid}->{'evalue'}."|\t";
				}
			}	 
			if ( defined $options->{'query-cover'} ) { 
				if ($LCALOOKUP->{$seqid}->{'qcover'} < $options->{'query-cover'}) {
					select OUTSCRAP;
					my $qcover = sprintf("%.3f", $LCALOOKUP->{$seqid}->{'qcover'});
					#print "query: ".$qcover."|\t";
				}
			}
			if ( defined $options->{'pid'}) { 
				if ($LCALOOKUP->{$seqid}->{'pid'} < $options->{'pid'}) {
					select OUTSCRAP;
					#print "pid:   ".$LCALOOKUP->{$seqid}->{'pid'}."|\t";
				}
			}
		} else { 
			if ($scrap == 1) { select OUTSCRAP; }
			#print "NoLCA:       |\t"; 
		}
		# actual printing to file
		print $cluster."\t";
		if (! defined $options->{'no-sample-counts'}) {
			if (defined $options->{'total-counts'}) {
				print $OTU->{$cluster}->{'total'}."\t";
			} else {
				foreach my $samp (@SAMPLE) {
		 			if (! defined $OTU->{$cluster}->{$samp}) { print "0\t"; }
					else { print $OTU->{$cluster}->{$samp}."\t"; } 
				}
			}
		} 
		
		if (defined $options->{'representative'}) {
			print "$seqid\t";
		}
		if (defined $LCALOOKUP->{$seqid}->{'txid'})
		{ 
			my $lineage = getLineage($LCALOOKUP->{$seqid}->{'txid'});
			$lineage =~ s/; $//;
			print $lineage."\n";
		}
		else { print "Unassignable\n";}
	}
	print STDOUT "DONE\n";
}

sub getLineage {
	my $id = shift;
	
	my $node;
	my @taxonomy;
	my $lineage;
	my $fulllineage = "";
	my @names;

	$node = $dbh->get_taxon(-taxonid => $id);
	if (! defined $node) { return "Unassignable"; }
	my $tree = new Bio::Tree::Tree();
	@taxonomy = $tree->get_lineage_nodes($node);
	push (@taxonomy, $node);
	if (defined $options->{'full-taxa'}) { 
		foreach my $taxon (@taxonomy) {                                
			# produces the full lineagei with ranks
			$fulllineage .= "[".$taxon->rank."] ".$taxon->scientific_name."; ";
		} 
	} else {
		# could prob be more efficient but will leave for now
		foreach my $rank (@ranks) {
			my $taxon;
			foreach my $nd (@taxonomy) {
				$taxon = $nd if ($nd->rank eq $rank);
			}
			if (defined $taxon) {
				my $R = $abv_ranks->{$rank};
				my $name = $taxon->scientific_name;
				$name =~ s/\.//g;
				$name =~ s/\s+/_/g;
				$lineage = $R."__".$name;
				push @names, $lineage;
			} else {
				if ($abv_ranks->{$rank} !~ /\w{2}/) {
					push @names, "$abv_ranks->{$rank}__";
				}
			}			
		}
		$fulllineage = join ("; ", @names);
	}
	return $fulllineage;	
}

sub cacheLCAtaxid {
	my ($lcafile) = @_;
	print STDOUT "Reading $lcafile...\n";
	open LCA, "<$lcafile" or die "Failed to open LCA file\n";
	my $database;
	my @repseqs;
	while (<LCA>) {
		chomp;
		my $line = $_;
		my @inputparser = split (/\t/, $line);
		my $currentseqid = $inputparser[0];
		$currentseqid =~ s/Query:\s?//;
		push @repseqs, $currentseqid;
		next if ($line =~ /No suitable matches found/ or $line !~ /LCA/);
		foreach my $item (@inputparser) {
			$item =~ s/\s//g;
			my ($key, $value) = split (":", $item);
			
			if ($key =~ /LCA/) { $LCALOOKUP->{$currentseqid}->{'txid'} = $value; }
			elsif ($key =~ /Name/) { $LCALOOKUP->{$currentseqid}->{'name'} = $value; }
			elsif ($key =~ /Rank/) { $LCALOOKUP->{$currentseqid}->{'rank'} = $value; }
			elsif ($key =~ /Evalue/) {
				my $minvalue = maxmin ($value, 'min');
				$LCALOOKUP->{$currentseqid}->{'evalue'} = $minvalue; 
			}
			elsif ($key =~ /Pid/) { 
				my $maxvalue = maxmin ($value, 'max');
				$LCALOOKUP->{$currentseqid}->{'pid'} = $maxvalue; 
			}
			elsif ($key =~ /Qcover/) {
				my $maxvalue = maxmin ($value, 'max');
				$LCALOOKUP->{$currentseqid}->{'qcover'} = $maxvalue; 
			}
		}
		if (! exists $LCALOOKUP->{$currentseqid}->{'evalue'}) {
			$options->{'evalue'} = undef;
		} 
		if (! exists $LCALOOKUP->{$currentseqid}->{'pid'}) {
			$options->{'pid'} = undef;
		}
		if (! exists $LCALOOKUP->{$currentseqid}->{'qcover'}) {
			$options->{'qcover'} = undef;
		}
	}
	close LCA;
	return @repseqs;
}


sub naturalsort {
	my ($P1, $p1, $M1) = $a =~ /^P(\d+)\.(\d+)_*M(\d+)$/;
	my ($P2, $p2, $M2) = $b =~ /^P(\d+)\.(\d+)_*M(\d+)$/;
	if ( not ( defined $P1 and defined $P2 and defined $p1 and defined $p2 and defined $M1 and defined $M2 ) ){
		return 0;
	}
	$P1 <=> $P2 || $p1 <=> $p2 || $M1 <=> $M2;
}

sub maxmin {
	my ($values, $order) = @_;
	if ($order ne "max" and $order ne "min") { return $values; }
	if ($values !~ /,/) { return $values; }
	my $max = 0;
	my $min = 100;
	my @list = split (",", $values);
	foreach my $value (@list) {
		$max = $value if ($value > $max);
		$min = $value if ($value < $min);
	}
	if ($order eq 'max') { return $max; }
	else { return $min; }
}

